# How nginx event module works
Before this article all of them are tell something about how config file is initialized for the whole nginx framework. Since now we will step the most important work as a web server of nginx and take an eye to it. We will learn about how nginx event module chooses IO multiplexing mothod based on operation system like `epoll`,`select` or `poll`, how nginx module is represented and so on.  
Nginx is a asynchoized event driven web server. As a result the core tasks of event framework are collecting, managing and distributing event which contains network event and timer event. Nothing could be more important than it in nginx.  

## 1. Basic structures in nginx event module
### 1.1 `ngx_event_module`
First we look the interface of nginx event module:  
```c
typedef struct {
    ngx_str_t              *name;

    void                 *(*create_conf)(ngx_cycle_t *cycle);
    char                 *(*init_conf)(ngx_cycle_t *cycle, void *conf);

    ngx_event_actions_t     actions;
} ngx_event_module_t;

```
### 1.2 `ngx_event_actions_t`
Different from other interface we can easily find that there is an action data member which every **event module MUST implement**. The action declaration is:  
```c
typedef struct {
    ngx_int_t  (*add)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);
    ngx_int_t  (*del)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);

    ngx_int_t  (*enable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);
    ngx_int_t  (*disable)(ngx_event_t *ev, ngx_int_t event, ngx_uint_t flags);

    ngx_int_t  (*add_conn)(ngx_connection_t *c);
    ngx_int_t  (*del_conn)(ngx_connection_t *c, ngx_uint_t flags);

    ngx_int_t  (*notify)(ngx_event_handler_pt handler);

    ngx_int_t  (*process_events)(ngx_cycle_t *cycle, ngx_msec_t timer,
                                 ngx_uint_t flags);

    ngx_int_t  (*init)(ngx_cycle_t *cycle, ngx_msec_t timer);
    void       (*done)(ngx_cycle_t *cycle);
} ngx_event_actions_t;
```
We can easily find that those functions are bridges to operate event module. The arguments of the first four functions receiving all contain type `ngx_event_t` which is the common event in nginx.  

### 1.3 `ngx_evnet_t`
The first question is that what is an event? According to nginx event driven framework, event refers to the moment when socket/file becomes readable/writable or timer expiring evnet. So as an event structure, it must contain following things:  
- where the event comes from. It maybe a socket, a file or a timer  
- flag to specify the detail of event, such as whether it's readable? If it's writable now?  

Points listed above are my interpreting data member. Let's look up the details in source code:  
- ready: whether event is ready to operate  
- instance: whether current event is valid and not expire  
- active: whether the event is active (so what is the definition of active?)
- timeout: check whether this event is timeout  
- deferred_accept: establish tcp connection until the read data packet arrives  
- handler: the callback when this event happendes(so what is the definition of event happening?)  

### 1.4 connection in nginx
There are so many important data member in connection, I only show some important things here. There are two data members which I  didn't understand at first time of reading book. They are reading/writing event corresponding to an event:  
```c
ngx_event_t *read;
ngx_event_t *write;
```
Those two are easily to understand. The system call `epoll` can only know a file descriptor(corresponding to a connection) is writeable/readable, but when it comes to other callstack it knows which connection owns event any more.  

## 2. When events and connections are created?  
All events no matter read events or write events are initialized at `ngx_init_cycle`. @todo: check if it's right and where is it.  
```c
    ngx_event_t              *read_events;
    ngx_event_t              *write_events;
```

Connections is managed by cycle by two tructs: `connections` and `free_connections`.  
```c
    ngx_connection_t         *connections;
    ngx_connection_t         *free_connections;
    ngx_uint_t                free_connection_n;
```
Let's look up about initializations of them. There is no doubt that all initialization works are done in `create_conf` and `init_conf` in corresponding module. After carefully finding it's found at function `ngx_event_process_init` as init_process data member in `ngx_module_t`.  
It allocates memory for those data member for further steps:  
```c
    cycle->read_events = ngx_alloc(sizeof(ngx_event_t) * cycle->connection_n,
                                   cycle->log);
    if (cycle->read_events == NULL) {
        return NGX_ERROR;
    }

    rev = cycle->read_events;
    for (i = 0; i < cycle->connection_n; i++) {
        rev[i].closed = 1;
        rev[i].instance = 1;
    }

    cycle->write_events = ngx_alloc(sizeof(ngx_event_t) * cycle->connection_n,
                                    cycle->log);
    if (cycle->write_events == NULL) {
        return NGX_ERROR;
    }
```
Attention that the large of read/write event array is equal to `connection_n`. The default value of `connection_n` is defined by a macro named `DEFAULT_CONNECTIONS` with value 512. It's done at `nginx-release-1.21.1\src\event\ngx_event.c:1325`  in function `ngx_event_core_init_conf`. Additional, it's in `ngx_event_core_module` module which is the same module to `ngx_event_process_init`.  
```c
    ngx_conf_init_uint_value(ecf->connections, DEFAULT_CONNECTIONS);
    cycle->connection_n = ecf->connections;
```

Now everything about this topic is clear. They are all initializing based on steps defined in `ngx_event_core_module`. And the default connection of a process is set by number 512, if it's defined at `nginx.conf` file and will be reset by callback in command list.  

### 2.1 When `ngx_event_process_init` is called as a single process?
It's called in function `ngx_single_process_cycle` at `\src\core\nginx.c:380`. Note that `ngx_event_core_module` always the first one in all event modules, this is made sure by `./configure` script.  
```c
    for (i = 0; cycle->modules[i]; i++) {
        if (cycle->modules[i]->init_process) {
            if (cycle->modules[i]->init_process(cycle) == NGX_ERROR) {
                /* fatal */
                exit(2);
            }
        }
    }
```

### 2.2 How nginx connects relatives between listening sockets and event module?  
This is the sequal of the privous article, in previous article we walked about **when and how nginx create listening sockets**. Here the attention will be put on how event module manages listening socket.  
As we learned from `UNIX NETWORK PROGRAMMING:VOLUMN 1` authored by W.Stevens.Richard, when a listening socket detects a new tcp connection it becomes readable as subscribe `EPOLLIN` in `epoll`. In nginx it doesn't take the method that solving events returned by `epoll` and chooses a function to deal with it. However, nginx bind a callback function to one event, if this event is actived by epoll and we just need to execute its callback function.  
As a result, after listening being initialized and starting listening, the read event of listening is set to `ngx_event_accept` defined at `n\src\event\ngx_event_accept.c:18`. Of course it will never change for unique task to handle new connection of listening sockets.  
 




